@@whitespace :: / +/
@@keyword :: case match lazy val var override def implicit object class trait
@@keyword :: import package super
# @@keyword :: null this

nl = {'\n'}+;
eol = ';' | nl;

UnicodeEscape = '\u' {'u'} HexDigit HexDigit HexDigit HexDigit;
HexDigit = /[0-9A-Fa-f]/;
whiteSpace = '\u0020' | '\u0009' | '\u000D' | '\u000A';
Upper = /[A-Z$_]/;
Lower = /[a-z]/;
Letter = Upper | Lower;
Digit = /\d/;
paren = '(' | ')' | '[' | ']' | '{' | '}';
delim = '`' | "'" | '"' | '.' | ';' | ',';
wildcard = '_';
Wildcard = '_';
arrow = '=>';
projectOp = '#';
Opchar = (!(whiteSpace | Upper | Lower | Letter | Digit | paren | delim)) PrintableChar;
PrintableChar = /[\u0020-\u007F]/;
CharEscapeSeq = '\' ('b' | 't' | 'n' | 'f' | 'r' | '"' | "'" | '\');

booleanLiteral = 'true' | 'false';
integerLiteral = (decimalNumeral | hexNumeral) ['L' | 'l'];
decimalNumeral = '0' | nonZeroDigit {Digit};
hexNumeral = '0' ('x' | 'X') HexDigit {HexDigit};
nonZeroDigit = /[1-9]/;

floatingPointLiteral =
  {Digit}+ '.' {Digit}+ [exponentPart] [floatType]
  | '.' {Digit}+ [exponentPart] [floatType]
  | {Digit}+ exponentPart [floatType]
  | {Digit}+ [exponentPart] floatType;
exponentPart = ('E' | 'e') ['+' | '-'] {Digit}+;
floatType = 'F' | 'f' | 'D' | 'd';

CharNoQuoteOrNewline = !(nl | "'") PrintableChar;
CharNoDoubleQuote = !'"' PrintableChar;
CharNoDoubleQuoteOrNewline = !(nl | '"') PrintableChar;
characterLiteral = "'" (CharNoQuoteOrNewline | UnicodeEscape | CharEscapeSeq) "'";

StringElement = CharNoDoubleQuoteOrNewline
  | UnicodeEscape
  | CharEscapeSeq;
stringLiteralData(token) = {StringElement};
singleLineStringLiteral = lquote:'"' data:stringLiteralData rquote:'"';
multiLineChars = {['"'] ['"'] CharNoDoubleQuote} {'"'};
multiLineStringLiteral = lquote:'"""' data:multiLineChars rquote:'"""';
stringLiteral =
  | singleLineStringLiteral
  | multiLineStringLiteral
  ;
symbolLiteral = "'" plainid;

# this is wrong
comment = '/*' /./ '*/'
  | '//' /./;

op = !arrow op:{Opchar}+;
# @name plainid = /[A-Z$_a-z][A-Z$_a-z0-9]*/;
plainid1(token) = Letter {Letter | Digit};
@name plainid = plainid1;
idOpSuffix = plainid Wildcard {Opchar}+;
quotedId = '`' stringLiteralData '`';
id = idOpSuffix | plainid | op | quotedId;

case = 'case';
match = 'match';
typekw = 'type';

literal = ['-'] integerLiteral
  | ['-'] floatingPointLiteral
  | booleanLiteral
  | characterLiteral
  | 'null'
  | stringLiteral
  | symbolLiteral
  ;

qualId = id {'.' id};
ids = id {',' id};

classQualifier = '[' id ']';
superAttr = [id '.'] 'super' [classQualifier] '.' id;
select = path '.' id;
@name stableId =
  | superAttr
  | select
  | id
  ;
thisRef = [id '.'] 'this';
path =
  | stableId
  | thisRef
  ;

functionArgTypes = infixType
  | '(' [ paramType {',' paramType } ] ')';
existentialClause = 'forSome' '{' existentialDcl {eol existentialDcl} '}';
existentialDcl = typekw typeDcl
  | 'val' valDcl;
typeProjection = regularType projectOp id;
simpleType = typeProjection
  | path '.' typekw
  | '(' types ')'
  | id:stableId;
typeArgs = lbrack:'[' types:types rbrack:']';
types = type {',' type};
refinement = [nl] '{' refineStat {eol refineStat} '}';
refineStat = dcl
  | typeDef;
appliedType = simple:simpleType args:typeArgs;
regularType = appliedType
  |simpleType;
annotType = regularType {annotation};
compoundType1 = compoundpre:annotType compound:{'with' annotType} [refine:refinement];
compoundType = compoundType1
  | refinement;
infixTypeRest = infix:id [nl:nl] rhs:compoundType;
infixType = infixhead:compoundType infixtail:{infixTypeRest};
functionType = functionArgTypes arrow type;
infixExistentialType = infixType [existentialClause];
type =
  | functionType
  | infixExistentialType;

ascription = ':' infixType
  | ':' annotation {annotation}
  | ':' wildcard '*';

patMat = scrutinee:simpleOrCompoundExpr match:match lbrace:'{' [nl]
cases:caseClauses [nl] rbrace:'}';

postfixExpr = infixExpr id eol;
infixOper =
  | infixExpr
  | simpleExpr
  ;
infixExpr = left:infixOper method:id [nl:nl] arg:infixOper;
prefixOperator = '-' | '+' | '~' | '!';
prefixExpr = prefix:prefixOperator expr:simpleExpr;
argumentExprs =
  | '(' [exprs ','] simpleOrCompoundExpr ':' wildcard '*' ')'
  | '(' [exprs] ')'
  | [nl] blockExpr
  ;
# accidentally deleted its usage
assignExpr =
  | [simpleExpr '.'] id '=' expr
  | simpleExpr1 argumentExprs '=' expr
  ;
simpleApplyExprPre =
  | literal
  | wildcard
  | '(' [exprs] ')'
  | simpleExpr typeArgs
  | path
  | simpleExprAttr
  ;
simpleApplyExpr = simpleApplyExprPre {argumentExprs}+;
simpleExprAttr = simpleExpr '.' id;
simpleExpr1 =
  | literal
  | wildcard
  | '(' [exprs] ')'
  | simpleExpr typeArgs
  | simpleApplyExpr
  | path
  | simpleExprAttr
  ;
classInstantiation = new:'new' templ:(classTemplate | templateBody);
etaExpansion = simpleExpr1 wildcard;
@name simpleExpr =
  | classInstantiation
  | blockExpr
  | etaExpansion
  | simpleExpr1
  ;
@name simpleOrCompoundExpr =
  | prefixExpr
  | infixExpr
  | postfixExpr
  | simpleExpr
  ;

@name expr =
  | (bindings | ['implicit'] id | wildcard) arrow expr
  | expr1
  ;
@name expr1 =
  | 'if' '(' expr ')' {nl} expr [[eol] 'else' expr]
  | 'while' '(' expr ')' {nl} expr
  | 'try' ('{' block '}' | expr) ['catch' '{' caseClauses '}'] ['finally' expr]
  | 'do' expr [eol] 'while' '(' expr ')'
  | 'for' ('(' enumerators ')' | '{' enumerators '}') {nl} ['yield'] expr
  | 'throw' expr
  | 'return' [expr]
  | patMat
  | simpleOrCompoundExpr
  | simpleOrCompoundExpr ascription
  ;
exprs = expr {',' expr};

enumerators = generator {eol generator};
generator = pattern1 '<-' expr {[eol] guard | eol pattern1 '=' expr};

simplePattern = wildcard
  | plainid
  | literal
  | stableId
  | stableId '(' [patterns] ')'
  | stableId '(' [patterns ','] [plainid '@'] '_*)'
  | '(' [patterns] ')';
pattern3 = simplePattern
  | simplePattern { id [nl] simplePattern };
pattern2 = plainid ['@' pattern3]
  | pattern3;
# cannot use `type` here, as it breaks case clauses by interpreting the arrow
# as part of a function type
pattern1 =
  | (plainid | wildcard) ':' (infixExistentialType | functionType)
  | pattern2;
pattern = pattern1 { '|' pattern1 };
patterns = pattern [',' patterns]
  | '_*';

guard = 'if' simpleOrCompoundExpr;
caseClause = start:case pat:pattern [guard:guard] arr:arrow block:block;
caseClausesRest = eol:eol case:caseClause;
caseClauses = first:caseClause rest:{caseClausesRest};

typeParam = id:(id | wildcard) [sub:typeParamClause]
[b:tpLowerBound] [ub:tpUpperBound] vbs:{tpViewBound} cbs:{tpContextBound};
typeParamClause = '[' variantTypeParam {',' variantTypeParam} ']';
typeParams = typeParam {',' typeParam};
funTypeParamClause = lbrack:'[' params:typeParams rbrack:']';
variantTypeParam = {annotation} ['+' | '-'] typeParam;
tpLowerBound = '>:' type;
tpUpperBound = '<:' type;
tpViewBound = '<%' type;
tpContextBound = ':' type;

paramClauses = explicit:{paramClause}+ [implicits:implicitParamClause];
paramClause = [nl] lpar:'(' !'implicit' [params:params] rpar:')';
implicitParamClause = [nl] lpar:'(' implicitkw:'implicit' params:params rpar:')';
params = param {',' param};
param = {anno:annotation} id:id [colon:':' tpe:paramType] [assign:'='
rhs:expr];
paramTypeLazy = arrow type;
paramTypeVariant = type '*';
paramType =
  | type
  | paramTypeLazy
  | paramTypeVariant;
classParamClauses = {classParamClause} [[nl] '(' 'implicit' classParams ')'];
classParamClause = [nl] '(' [classParams] ')';
classParams = classParam {',' classParam};
classParam = {annotation} {modifier} [('val' | 'var')] id ':' paramType [' = ' expr];
bindings = '(' binding {',' binding} ')';
binding = (id | wildcard) [':' type];

modifier = localModifier
  | accessModifier
  | 'override';
localModifier = 'abstract'
  | 'final'
  | 'sealed'
  | 'implicit'
  | 'lazy';
accessModifier = ('private' | 'protected') [accessQualifier];
accessQualifier = '[' (id | 'this') ']';

annotation = '@' regularType {argumentExprs};
constrAnnotation = '@' regularType argumentExprs;

templateBody = [nl] '{' [selfType] templateStat {eol templateStat} '}';
templateStatDef = {anno:annotation [nl]} {mod:modifier} def:def;
templateStatDcl = {anno:annotation [nl]} {mod:modifier} dcl:dcl;
templateStat =
  | import
  | templateStatDef
  | templateStatDcl
  | expr;
selfType = id [':' type] arrow
  | 'this' ':' type arrow;

import = 'import' importExpr {',' importExpr};
importExpr = stableId '.' (id | wildcard | importSelectors);
importSelectors = '{' {importSelector ','} (importSelector | wildcard) '}';
importSelector = id [arrow id | arrow wildcard];

dcl = key:'val' dcl:valDcl
  | key:'var' dcl:valDcl
  | key:'def' dcl:funDcl
  | key:typekw {nl} dcl:typeDcl;

valDcl = ids ':' type;
funDcl = sig:funSig [':' type:type];
typeDcl = id [typeParamClause] ['>:' type] ['<:' type];

patDef = pats:(pattern2 {',' pattern2}) [colon:':' tpe:type] assign:'=' rhs:expr;
varDef = patDef
  | ids ':' type '=' wildcard;

funSig = id:id [nl1:nl] [tparams:funTypeParamClause] [nl2:nl]
[paramss:paramClauses];
funDefFull = sig:funSig [nl:nl] [colon:':' type:type] assign:'=' rhs:expr;
funDefUnit = sig:funSig [nl:nl] '{' rhs:block '}';
funDefCtor = 'this' paramClauses (' = ' constrExpr | [nl] constrBlock);
funDef1 =
  | funDefFull
  | funDefUnit
  | funDefCtor
  ;
funDef = defkw:'def' def:funDef1;

typeDef = typekw:typekw nls:{nl} id:id [params:typeParamClause] assign:'=' rhs:type;
valVarDef = val:'val' def:patDef;
varVarDef = var:'var' def:varDef;
patVarDef =
  | valVarDef
  | varVarDef
  ;
def =
  | patVarDef
  | funDef
  | typeDef
  | tmplDef
  ;

resultExpr = expr1
  | (bindings | (['implicit'] id | wildcard) ':' compoundType) arrow block;
blockStatDef = {annotation} ['implicit' | 'lazy'] def;
blockStatTemplDef = {annotation} {localModifier} tmplDef;
blockStat =
  | import
  | blockStatDef
  | blockStatTemplDef
  | expr1
  ;
blockRest =  eol:eol stat:blockStat;
block = first:blockStat rest:{blockRest} [result:resultExpr];
ccBlockExpr = lbrace:'{' [nl] cases:caseClauses [nl] rbrace:'}';
simpleBlockExpr = lbrace:'{' [nl] block:block [nl] rbrace:'}';
blockExpr =
  | ccBlockExpr
  | simpleBlockExpr
  ;

tmplDef =
  | [case] 'class' classDef
  | [case] 'object' objectDef
  | 'trait' traitDef
  ;
classDef = id [typeParamClause] {constrAnnotation} [accessModifier] classParamClauses classTemplateOpt;
traitDef = id [typeParamClause] traitTemplateOpt;
objectDef = id classTemplateOpt;
classTemplateOpt = 'extends' classTemplate | [['extends'] templateBody];
traitTemplateOpt = 'extends' traitTemplate | [['extends'] templateBody];
classTemplate = [earlyDefs] classParents [templateBody];
traitTemplate = [earlyDefs] traitParents [templateBody];
classParents = constr {'with' annotType};
traitParents = annotType {'with' annotType};
constr = annotType {argumentExprs};
earlyDefs = '{' [earlyDef {eol earlyDef}] '}' 'with';
earlyDef = {annotation [nl]} {modifier} patVarDef;

constrExpr = selfInvocation
  | constrBlock;
constrBlock = '{' selfInvocation {eol blockStat} '}';
selfInvocation = 'this' argumentExprs {argumentExprs};

topStatSeq = topStat {eol topStat};
topStat = {annotation [nl]} {modifier} tmplDef
  | import
  | packaging
  | packageObject;
packaging = 'package' qualId [nl] '{' topStatSeq '}';
packageObject = 'package' 'object' objectDef;

compilationUnit = {'package' qualId eol} topStatSeq;
