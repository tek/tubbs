@@keyword :: case match lazy val var override def implicit object class trait
@@keyword :: import package

UnicodeEscape = '\u' {'u'} HexDigit HexDigit HexDigit HexDigit;
HexDigit = /[0-9A-Fa-f]/;
whiteSpace = '\u0020' | '\u0009' | '\u000D' | '\u000A';
Upper = /[A-Z$_]/;
Lower = /[a-z]/;
Letter = Upper | Lower;
Digit = /\d/;
paren = '(' | ')' | '[' | ']' | '{' | '}';
delim = '`' | "'" | '"' | '.' | ';' | ',';
wildcard = '_';
arrow = '=>';
Opchar = (!(whiteSpace | Upper | Lower | Letter | Digit | paren | delim)) PrintableChar;
PrintableChar = /[\u0020-\u007F]/;
CharEscapeSeq = '\' ('b' | 't' | 'n' | 'f' | 'r' | '"' | "'" | '\');

@name op = {Opchar}+;
@name varid = (Lower IdRest);
@name plainid = !arrow ((Upper IdRest) | varid | op);
@name id = plainid | '`' stringLiteral '`';
IdRest = {Letter | Digit} ['_' op];

booleanLiteral = 'true' | 'false';
integerLiteral = (decimalNumeral | hexNumeral) ['L' | 'l'];
decimalNumeral = '0' | nonZeroDigit {Digit};
hexNumeral = '0' ('x' | 'X') HexDigit {HexDigit};
nonZeroDigit = /[1-9]/;

floatingPointLiteral =
  {Digit}+ '.' {Digit}+ [exponentPart] [floatType]
  | '.' {Digit}+ [exponentPart] [floatType]
  | {Digit}+ exponentPart [floatType]
  | {Digit}+ [exponentPart] floatType;
exponentPart = ('E' | 'e') ['+' | '-'] {Digit}+;
floatType = 'F' | 'f' | 'D' | 'd';

CharNoQuoteOrNewline = !(nl | "'") PrintableChar;
CharNoDoubleQuote = !'"' PrintableChar;
CharNoDoubleQuoteOrNewline = !(nl | '"') PrintableChar;
characterLiteral = "'" (CharNoQuoteOrNewline | UnicodeEscape | CharEscapeSeq) "'";

stringLiteral = '"' {StringElement} '"'
  | '"""' multiLineChars '"""';
StringElement = CharNoDoubleQuoteOrNewline
  | UnicodeEscape
  | CharEscapeSeq;
multiLineChars = {['"'] ['"'] CharNoDoubleQuote} {'"'};

symbolLiteral = "'" plainid;
comment = '/*' /./ '*/'
  | '//' /./;
nl = '\n';
eol = ';' | {nl}+;

case = 'case';
match = 'match';
typekw = 'type';

literal = ['-'] integerLiteral
  | ['-'] floatingPointLiteral
  | booleanLiteral
  | characterLiteral
  | stringLiteral
  | symbolLiteral
  | 'null';

qualId = id {'.' id};
ids = id {',' id};

path = stableId
  | [id '.'] 'this';
stableId = id
  | path '.' id
  | [id '.'] 'super' [classQualifier] '.' id;
classQualifier = '[' id ']';

functionArgTypes = infixType
  | '(' [ paramType {',' paramType } ] ')';
existentialClause = 'forSome' '{' existentialDcl {eol existentialDcl} '}';
existentialDcl = typekw typeDcl
  | 'val' valDcl;
simpleType = regularType '#' id
  | path '.' typekw
  | '(' types ')'
  | id:stableId;
typeArgs = '[' types:types ']';
types = type {',' type};
refinement = [nl] '{' refineStat {eol refineStat} '}';
refineStat = dcl
  | typekw typeDef;
appliedType = simple:simpleType args:typeArgs;
regularType = appliedType
  |simpleType;
annotType = regularType {annotation};
compoundType = annotType {'with' annotType} [refinement]
  | refinement;
infixType = compoundType {id [nl] compoundType};
functionType = functionArgTypes arrow type;
infixExistentialType = infixType [existentialClause];
type =
  | functionType
  | infixExistentialType;

ascription = ':' infixType
  | ':' annotation {annotation}
  | ':' '_' '*';

@name
expr = (bindings | ['implicit'] id | '_') arrow expr
  | expr1;
@name
expr1 = 'if' '(' expr ')' {nl} expr [[eol] 'else' expr]
  | 'while' '(' expr ')' {nl} expr
  | 'try' ('{' block '}' | expr) ['catch' '{' caseClauses '}'] ['finally' expr]
  | 'do' expr [eol] 'while' '(' expr ')'
  | 'for' ('(' enumerators ')' | '{' enumerators '}') {nl} ['yield'] expr
  | 'throw' expr
  | 'return' [expr]
  | [simpleExpr '.'] id ' = ' expr
  | simpleExpr2 argumentExprs ' = ' expr
  | postfixExpr
  | postfixExpr ascription
  | patMat;

patMat = scrutinee:postfixExpr match:match lbrace:'{' cases:caseClauses rbrace:'}';

# @name postfixExpr = infixExpr [id eol];
@name postfixExpr = infixExpr;
@name infixExpr = infixExpr1;
@name infixExpr1 = prefixExpr
  | infixExpr1 id [nl] infixExpr1;
prefixExpr = ['-' | '+' | '~' | '!'] simpleExpr;
@name simpleExpr = simpleExpr1;
simpleExpr1 = 'new' (classTemplate | templateBody)
  | blockExpr
  | simpleExpr2 ['_'];
simpleExpr2 = literal
  | path
  | '_'
  | '(' [exprs] ')'
  | simpleExpr '.' id
  | simpleExpr typeArgs
  | simpleExpr2 argumentExprs;
exprs = expr {',' expr};
argumentExprs = '(' [exprs] ')'
  | '(' [exprs ','] postfixExpr ':' '_' '*' ')'
  | [nl] blockExpr;
blockExpr = '{' caseClauses '}'
  | '{' block '}';
block = blockStat { eol blockStat } [resultExpr];
@name blockStat = blockStat1;
blockStat1 = import
  | {annotation} ['implicit' | 'lazy'] def
  | {annotation} {localModifier} tmplDef
  | expr1;
resultExpr = expr1
  | (bindings | (['implicit'] id | '_') ':' compoundType) arrow block;

enumerators = generator {eol generator};
generator = pattern1 '<-' expr {[eol] guard | eol pattern1 '=' expr};

simplePattern = '_'
  | varid
  | literal
  | stableId
  | stableId '(' [patterns] ')'
  | stableId '(' [patterns ','] [varid '@'] '_*)'
  | '(' [patterns] ')';
pattern3 = simplePattern
  | simplePattern { id [nl] simplePattern };
pattern2 = varid ['@' pattern3]
  | pattern3;
# cannot use `type` here, as it breaks case clauses by interpreting the arrow
# as part of a function type
pattern1 =
  | (varid | wildcard) ':' (infixExistentialType | functionType)
  | pattern2;
pattern = pattern1 { '|' pattern1 };
patterns = pattern [',' patterns]
  | '_*';

guard = 'if' postfixExpr;
caseClause = start:case pat:pattern [guard:guard] arr:arrow block:block;
caseClauses = cases:{ caseClause }+;

typeParamClause = '[' variantTypeParam {',' variantTypeParam} ']';
funTypeParamClause = '[' params:(typeParam {',' typeParam}) ']';
variantTypeParam = {annotation} ['+' | '-'] typeParam;
typeParam = (id | '_') [typeParamClause] ['>:' type] ['<:' type] {'<%' type} {':' type};
paramClauses = {params:paramClause} [[nl] implicits:implicitParamClause];
paramClause = [nl] start:'(' !'implicit' [params] ')';
implicitParamClause = start:'(' 'implicit' params ')';
params = param {',' param};
param = {annotation} id [':' paramType] ['=' expr];
paramType = type
  | arrow type
  | type '*';
classParamClauses = {classParamClause} [[nl] '(' 'implicit' classParams ')'];
classParamClause = [nl] '(' [classParams] ')';
classParams = classParam {',' classParam};
classParam = {annotation} {modifier} [('val' | 'var')] id ':' paramType [' = ' expr];
bindings = '(' binding {',' binding} ')';
binding = (id | '_') [':' type];

modifier = localModifier
  | accessModifier
  | 'override';
localModifier = 'abstract'
  | 'final'
  | 'sealed'
  | 'implicit'
  | 'lazy';
accessModifier = ('private' | 'protected') [accessQualifier];
accessQualifier = '[' (id | 'this') ']';

annotation = '@' regularType {argumentExprs};
constrAnnotation = '@' regularType argumentExprs;

templateBody = [nl] '{' [selfType] templateStat {eol templateStat} '}';
templateStat =
  | import
  | {anno:annotation [nl]} {mod:modifier} def:def
  | {anno:annotation [nl]} {mod:modifier} dcl:dcl
  | expr;
selfType = id [':' type] arrow
  | 'this' ':' type arrow;

import = 'import' importExpr {',' importExpr};
importExpr = stableId '.' (id | '_' | importSelectors);
importSelectors = '{' {importSelector ','} (importSelector | '_') '}';
importSelector = id [arrow id | arrow '_'];

dcl = key:'val' dcl:valDcl
  | key:'var' dcl:varDcl
  | key:'def' dcl:funDcl
  | key:typekw {nl} dcl:typeDcl;

valDcl = ids ':' type;
varDcl = ids ':' type;
funDcl = sig:funSig [':' type:type];
funSig = id:id [tparams:funTypeParamClause] paramss:paramClauses;
typeDcl = id [typeParamClause] ['>:' type] ['<:' type];

patVarDef = 'val' patDef
  | 'var' varDef;
def = patVarDef
  | 'def' funDef
  | typekw {nl} typeDef
  | tmplDef;
patDef = pattern2 {',' pattern2} [':' type] '=' expr;
varDef = patDef
  | ids ':' type ' = ' '_';
funDef = sig:funSig [':' type:type] '=' rhs:expr
  | sig:funSig [nl] '{' rhs:block '}'
  | 'this' paramClause paramClauses (' = ' constrExpr | [nl] constrBlock);
typeDef = id [typeParamClause] '=' type;

tmplDef = [case] 'class' classDef
  | [case] 'object' objectDef
  | 'trait' traitDef;
classDef = id [typeParamClause] {constrAnnotation} [accessModifier] classParamClauses classTemplateOpt;
traitDef = id [typeParamClause] traitTemplateOpt;
objectDef = id classTemplateOpt;
classTemplateOpt = 'extends' classTemplate | [['extends'] templateBody];
traitTemplateOpt = 'extends' traitTemplate | [['extends'] templateBody];
classTemplate = [earlyDefs] classParents [templateBody];
traitTemplate = [earlyDefs] traitParents [templateBody];
classParents = constr {'with' annotType};
traitParents = annotType {'with' annotType};
constr = annotType {argumentExprs};
earlyDefs = '{' [earlyDef {eol earlyDef}] '}' 'with';
earlyDef = {annotation [nl]} {modifier} patVarDef;

constrExpr = selfInvocation
  | constrBlock;
constrBlock = '{' selfInvocation {eol blockStat} '}';
selfInvocation = 'this' argumentExprs {argumentExprs};

topStatSeq = topStat {eol topStat};
topStat = {annotation [nl]} {modifier} tmplDef
  | import
  | packaging
  | packageObject;
packaging = 'package' qualId [nl] '{' topStatSeq '}';
packageObject = 'package' 'object' objectDef;

compilationUnit = {'package' qualId eol} topStatSeq;
