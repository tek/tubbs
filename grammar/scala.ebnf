@@whitespace :: / +/
@@keyword :: case match lazy val var override def implicit object class trait
@@keyword :: import package super
# @@keyword :: null this

nl = {'\n'}+;
seminl = ';' [nl];
eol = nl | seminl;

UnicodeEscape = '\u' {'u'} HexDigit HexDigit HexDigit HexDigit;
HexDigit = /[0-9A-Fa-f]/;
WhiteSpace = '\u0020' | '\u0009' | '\u000D' | '\u000A';
Upper = /[A-Z$_]/;
Lower = /[a-z]/;
Letter = Upper | Lower;
Digit = /\d/;
paren = '(' | ')' | '[' | ']' | '{' | '}';
delim = '`' | "'" | '"' | '.' | ';' | ',';
assign = '=';
wildcard = '_';
Wildcard = '_';
arrow = '=>';
projectOp = '#';
Opchar = (!(WhiteSpace | Upper | Lower | Letter | Digit | paren | delim | blockCommentStart)) PrintableChar;
PrintableChar = /[\u0020-\u007F]/;
CharEscapeSeq = '\' ('b' | 't' | 'n' | 'f' | 'r' | '"' | "'" | '\');

booleanLiteral = 'true' | 'false';
integerLiteral = (decimalNumeral | hexNumeral) ['L' | 'l'];
decimalNumeral = '0' | nonZeroDigit {Digit};
hexNumeral = '0' ('x' | 'X') HexDigit {HexDigit};
nonZeroDigit = /[1-9]/;

floatingPointLiteral =
  {Digit}+ '.' {Digit}+ [exponentPart] [floatType]
  | '.' {Digit}+ [exponentPart] [floatType]
  | {Digit}+ exponentPart [floatType]
  | {Digit}+ [exponentPart] floatType;
exponentPart = ('E' | 'e') ['+' | '-'] {Digit}+;
floatType = 'F' | 'f' | 'D' | 'd';

CharNoQuoteOrNewline = !(nl | "'") PrintableChar;
CharNoDoubleQuote = !'"' PrintableChar;
CharNoDoubleQuoteOrNewline = !(nl | '"') PrintableChar;
characterLiteral = "'" (CharNoQuoteOrNewline | UnicodeEscape | CharEscapeSeq) "'";

StringElement = CharNoDoubleQuoteOrNewline
  | UnicodeEscape
  | CharEscapeSeq;
stringLiteralData(token) = {StringElement};
singleLineStringLiteral = lquote:'"' data:stringLiteralData rquote:'"';
multiLineChars = {['"'] ['"'] CharNoDoubleQuote} {'"'};
multiLineStringLiteral = lquote:'"""' data:multiLineChars rquote:'"""';
stringLiteral =
  | singleLineStringLiteral
  | multiLineStringLiteral
  ;
symbolLiteral = "'" plainidName;

blockCommentStart = '/*';
blockCommentEnd = '*/';
blockCommentChar1 = /./ | nl;
blockCommentChar = !blockCommentEnd blockCommentChar1;
eolCommentStart = '//';
eolCommentChar = !nl /./;
blockCommentContent(token) = {blockCommentChar};
eolCommentContent(token) = {eolCommentChar};
blockComment = start:blockCommentStart content:blockCommentContent
end:blockCommentEnd;
eolComment = start:eolCommentStart content:eolCommentContent &nl;
comment =
  | blockComment
  | eolComment
  ;

op = !(arrow | assign) op:{Opchar}+;
plainid(token) = Letter {Letter | Digit};
@name plainidName = plainid;
idOpSuffix = plainidName Wildcard {Opchar}+;
quotedId = '`' stringLiteralData '`';
id =
  | idOpSuffix
  | plainidName
  | op
  | quotedId
  ;

case = 'case';
match = 'match';
typekw = 'type';

literal = ['-'] integerLiteral
  | ['-'] floatingPointLiteral
  | booleanLiteral
  | characterLiteral
  | 'null'
  | stringLiteral
  | symbolLiteral
  ;

qualId = id {'.' id};
ids = id {',' id};

classQualifier = '[' id ']';
superAttr = [id '.'] 'super' [classQualifier] '.' id;
selectpre1 =
  | thisRef
  | superAttr
  | id
  ;
selectpre = selector:selectpre1 dot:'.';
select = pre:{selectpre}+ id:id;
stableId =
  | superAttr
  | select
  | id
  ;
thisRef = [id '.'] 'this';
path =
  | thisRef
  | stableId
  ;

functionArgTypes = infixType
  | '(' [ paramType {',' paramType } ] ')';
existentialClause = 'forSome' '{' existentialDcl {eol existentialDcl} '}';
existentialDcl = typekw typeDcl
  | 'val' valDcl;
typeProjection = regularType projectOp id;
simpleType = typeProjection
  | path '.' typekw
  | '(' types ')'
  | id:stableId;
typeArgs = lbrack:'[' types:types rbrack:']';
types = type {',' type};
refinement = [nl] '{' refineStat {eol refineStat} '}';
refineStat = dcl
  | typeDef;
appliedType = simple:simpleType args:typeArgs;
regularType = appliedType
  |simpleType;
annotType = regularType {annotation};
compoundType1 = compoundpre:annotType compound:{'with' annotType} [refine:refinement];
compoundType = compoundType1
  | refinement;
infixTypeRest = infix:id [nl:nl] rhs:compoundType;
infixType = infixhead:compoundType infixtail:{infixTypeRest};
functionType = functionArgTypes arrow type;
infixExistentialType = infixType [existentialClause];
type =
  | functionType
  | infixExistentialType;

ascription = ':' infixType
  | ':' annotation {annotation}
  | ':' wildcard '*';

patMat = scrutinee:simpleOrCompoundExpr match:match lbrace:'{' [nl]
cases:caseClauses [nl] rbrace:'}';


bindings = '(' binding {',' binding} ')';
binding = (id | wildcard) [':' type];

postfixExpr = infixExpr id eol;
infixOper =
  | infixExpr
  | simpleExpr
  ;
infixExpr = left:infixOper method:id [nl:nl] arg:infixOper;
prefixOperator = '-' | '+' | '~' | '!';
prefixExpr = prefix:prefixOperator expr:simpleExpr;
simpleAssignExpr = [pre:simpleExpr dot:'.'] id:id assign:'=' rhs:expr;
applyAssignExpr = simpleExpr1 argumentsExpr '=' expr;
assignExpr =
  | simpleAssignExpr
  | applyAssignExpr
  ;
argumentExpr =
  | simpleAssignExpr
  | expr
  ;
argumentExprsTail = comma:',' arg:argumentExpr;
argumentExprs = first:argumentExpr rest:{argumentExprsTail};
arguments = lpar:'(' [args:argumentExprs] rpar:')';
splat = expr:simpleOrCompoundExpr colon:':' wildcard:wildcard aster:'*';
argumentsWithSplat =
  lpar:'(' regular:[args:argumentExprs comma:','] splat:splat rpar:')';
# FIXME nl before blockExpr? foo { a } is ok, but foo \n { a }?
argumentsBlock = [nl] blockExpr;
argumentsExpr =
  | argumentsWithSplat
  | arguments
  | argumentsBlock
  ;
simpleApplyExprPre1 =
  | simpleExprAttr
  | literal
  | wildcard
  | '(' [exprs] ')'
  | simpleExpr typeArgs
  | path
  ;
simpleExprAttr = simpleApplyExprPre1 '.' id;
simpleApplyExprPre =
  | simpleExprAttr
  | simpleApplyExprPre1
  ;
simpleApplyExpr = pre:simpleApplyExprPre args:{argumentsExpr}+;
simpleExpr1 =
  | '(' [exprs] ')'
  | simpleExpr typeArgs
  | simpleApplyExpr
  | path
  | literal
  | wildcard
  ;
classInstantiation = new:'new' templ:(classTemplate | templateBody);
etaExpansion = simpleExpr1 wildcard;
@name simpleExpr =
  | classInstantiation
  | blockExpr
  | etaExpansion
  | simpleExpr1
  ;
@name simpleOrCompoundExpr =
  | prefixExpr
  | infixExpr
  | postfixExpr
  | simpleApplyExpr
  | simpleExprAttr
  | simpleExpr
  ;
@name expr1 =
  | 'if' '(' expr ')' {nl} expr [[eol] 'else' expr]
  | 'while' '(' expr ')' {nl} expr
  | 'try' ('{' block '}' | expr) ['catch' '{' caseClauses '}'] ['finally' expr]
  | 'do' expr [eol] 'while' '(' expr ')'
  | 'for' ('(' enumerators ')' | '{' enumerators '}') {nl} ['yield'] expr
  | 'throw' expr
  | 'return' [expr]
  | patMat
  | simpleOrCompoundExpr
  | simpleOrCompoundExpr ascription
  ;
@name expr =
  | (bindings | ['implicit'] id | wildcard) arrow expr
  | expr1
  ;
exprs = expr {',' expr};

enumerators = generator {eol generator};
generator = pattern1 '<-' expr {[eol] guard | eol pattern1 '=' expr};

simplePattern = wildcard
  | plainidName
  | literal
  | stableId
  | stableId '(' [patterns] ')'
  | stableId '(' [patterns ','] [plainidName '@'] '_*)'
  | '(' [patterns] ')';
pattern3 = simplePattern
  | simplePattern { id [nl] simplePattern };
pattern2 = plainidName ['@' pattern3]
  | pattern3;
# cannot use `type` here, as it breaks case clauses by interpreting the arrow
# as part of a function type
pattern1 =
  | (plainidName | wildcard) ':' (infixExistentialType | functionType)
  | pattern2;
pattern = pattern1 { '|' pattern1 };
patterns = pattern [',' patterns]
  | '_*';

guard = 'if' simpleOrCompoundExpr;
caseClause = start:case pat:pattern [guard:guard] arr:arrow block:block;
caseClausesRest = eol:eol case:caseClause;
caseClauses = first:caseClause rest:{caseClausesRest};

typeParam = id:(id | wildcard) [sub:typeParamClause]
[b:tpLowerBound] [ub:tpUpperBound] vbs:{tpViewBound} cbs:{tpContextBound};
typeParamClause = '[' variantTypeParam {',' variantTypeParam} ']';
typeParams = typeParam {',' typeParam};
funTypeParamClause = lbrack:'[' params:typeParams rbrack:']';
variantTypeParam = {annotation} ['+' | '-'] typeParam;
tpLowerBound = '>:' type;
tpUpperBound = '<:' type;
tpViewBound = '<%' type;
tpContextBound = ':' type;

paramTypeLazy = arrow type;
paramTypeVariant = type '*';
paramType =
  | type
  | paramTypeLazy
  | paramTypeVariant;
param = {anno:annotation} id:id [colon:':' tpe:paramType] [assign:'='
rhs:expr];
params = param {',' param};
paramClause = [nl1:nl] lpar:'(' [nl2:nl] !'implicit' [params:params] [nl3:nl]
rpar:')';
implicitParamClause = [nl1:nl] lpar:'(' [nl2:nl] implicitkw:'implicit' [nl3:nl]
params:params [nl4:nl] rpar:')';
paramClauses = explicit:{paramClause}+ [implicits:implicitParamClause];

classParam = {annotation} {modifier} [('val' | 'var')] id ':' paramType [' = ' expr];
classParams = classParam {',' classParam};
classParamClause = [nl] '(' [classParams] ')';
classParamClauses = {classParamClause} [[nl] '(' 'implicit' classParams ')'];

modifier = localModifier
  | accessModifier
  | 'override';
localModifier = 'abstract'
  | 'final'
  | 'sealed'
  | 'implicit'
  | 'lazy';
accessModifier = ('private' | 'protected') [accessQualifier];
accessQualifier = '[' (id | 'this') ']';

annotation = '@' regularType {argumentsExpr};
constrAnnotation = '@' regularType argumentsExpr;

templateStatDef = {anno:annotation [nl]} {mod:modifier} def:def;
templateStatDcl = {anno:annotation [nl]} {mod:modifier} dcl:dcl;
templateStat =
  | comment
  | import
  | templateStatDef
  | templateStatDcl
  | expr;
templateStats = [selfType] [nl] [templateStat {eol templateStat}];
templateBody = [nl] '{' [nl] templateStats [nl] '}';
selfType = id [':' type] arrow
  | 'this' ':' type arrow;

import = 'import' importExpr {',' importExpr};
importExprPre = id '.';
importExpr = {importExprPre}+ (id | wildcard | importSelectors);
importSelectors = '{' {importSelector ','} (importSelector | wildcard) '}';
importSelector = id [arrow id | arrow wildcard];

dcl = key:'val' dcl:valDcl
  | key:'var' dcl:valDcl
  | key:'def' dcl:funDcl
  | key:typekw {nl} dcl:typeDcl;

valDcl = ids ':' type;
funDcl = sig:funSig [':' type:type];
typeDcl = id [typeParamClause] ['>:' type] ['<:' type];

patDef = pats:(pattern2 {',' pattern2}) [colon:':' tpe:type] assign:'=' rhs:expr;
varDef = patDef
  | ids ':' type '=' wildcard;

funSig = id:id [nl1:nl] [tparams:funTypeParamClause] [nl2:nl]
[paramss:paramClauses];
funDefFull = sig:funSig [nl1:nl] [colon:':' [nl2:nl] type:type] [nl3:nl] assign:'=' [nl4:nl] rhs:expr;
funDefUnit = sig:funSig [nl:nl] '{' rhs:block '}';
funDefCtor = 'this' paramClauses (' = ' constrExpr | [nl] constrBlock);
funDef1 =
  | funDefFull
  | funDefUnit
  | funDefCtor
  ;
funDef = defkw:'def' def:funDef1;

typeDef = typekw:typekw nls:{nl} id:id [params:typeParamClause] assign:'=' rhs:type;
valVarDef = val:'val' def:patDef;
varVarDef = var:'var' def:varDef;
patVarDef =
  | valVarDef
  | varVarDef
  ;
def =
  | patVarDef
  | funDef
  | typeDef
  | tmplDef
  ;

resultExpr = expr1
  | (bindings | (['implicit'] id | wildcard) ':' compoundType) arrow block;
blockStatDef = {annotation} ['implicit' | 'lazy'] def;
blockStatTemplDef = {annotation} {localModifier} tmplDef;
blockStat =
  | comment
  | import
  | blockStatDef
  | blockStatTemplDef
  | expr1
  ;
blockRest = eol:eol stat:blockStat;
block = first:blockStat rest:{blockRest} [result:resultExpr];
ccBlockExpr = lbrace:'{' [nl] cases:caseClauses [nl] rbrace:'}';
simpleBlockExpr = lbrace:'{' [nl] block:block [nl] rbrace:'}';
blockExpr =
  | ccBlockExpr
  | simpleBlockExpr
  ;

classDef = id [typeParamClause] {constrAnnotation} [accessModifier] classParamClauses classTemplateOpt;
traitDef = [nl] id [nl] [typeParamClause] [nl] traitTemplateOpt;
objectDef = id classTemplateOpt;
classTemplateOpt = 'extends' classTemplate | [['extends'] templateBody];
traitTemplateOpt = 'extends' traitTemplate | [['extends'] templateBody];
classTemplate = [earlyDefs] classParents [templateBody];
traitTemplate = [earlyDefs] traitParents [templateBody];
classParents = constr {'with' annotType};
traitParents = annotType {'with' annotType};
constr = annotType {argumentsExpr};
earlyDefs = '{' [nl] [earlyDef {eol earlyDef}] [nl] '}' [nl] 'with';
earlyDef = {annotation [nl]} {modifier} patVarDef;
class = [case] 'class' classDef;
module = [case] 'object' objectDef;
trait = 'trait' traitDef;
tmplDef =
  | class
  | module
  | trait
  ;

constrExpr = selfInvocation
  | constrBlock;
constrBlock = '{' selfInvocation {eol blockStat} '}';
selfInvocation = 'this' argumentsExpr {argumentsExpr};

topStat =
  | comment
  | {annotation [nl]} {modifier} tmplDef
  | import
  | packaging
  | packageObject
  | nl
  ;
topStatSeq = topStat {eol topStat};
packaging = 'package' qualId [nl] '{' topStatSeq '}';
packageObject = 'package' 'object' objectDef;
package = 'package' qualId;

compilationUnit = initialcomment:{comment nl} package:{package eol}
stats:topStatSeq;
